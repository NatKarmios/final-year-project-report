%!TEX root = ../main.tex

\chapter{Evaluation}\label{sec:eval}

Due to the scarcity of similar tools, points of strong comparison for Gillian's
new debugger are few and far between. The best options to evaluate this project
against are the options available to Gillian users prior to this project (or
prior to any debugging work being done at all, as this project comes after
multiple years of work to this end), and to VeriFast, Gillian's closest
contemporary.

\section{Vs. Previous Gillian Debugging Methods}

Compared to the original debugging method --- manually reading the log file
resulting from verification --- the advantages of the visual debugger are
obvious. Not only does the file log require a deep understanding of Gillian's
internals, but it contains a vast amount of detail, often obfuscating the
information relevant to the encountered error. \sacha{It's a bit more than that. There's also the fact that reading text that describes a process is always less easy than reading a diagram that describes the same process. It's also, quite importantly, about how to navigate the log data.}
Even in the simple case of the recursive list length function, which was used as
a baseline throughout the project, a total of 9328 lines of logging output is
generated during verification. As a more precise comparison, about 1500 of those
lines concern unification of the postconditions, with a high degree of
redundancy and verbosity. This contrasts with what is essentially a few lines of
text in the debugger interface, with more detail available as and when the user
requires. Compared to the clear, clean, and concise interface of the new
solution, a far more ideal debugging process has been presented --- even those
with a deep understanding of Gillian, who are well acclimated to debugging via
the file log, intend to use this as their primary method of debugging moving
forwards.

The new debugger is also leaps and bounds ahead of the previous iteration;
aside from not having any unification information whatsoever, its use requires
a user to understand the quirks of the solution, such as branches being executed
one after the other with no means of discerning between then. The first debugger
was very much a case of attempting to move Gillian a step closer to debugging in
whatever manner was available, rather than setting out a clear vision of what
prospective users would desire from a program verification debugger, and working
to meet that goal.


\section{Vs. VeriFast}

VeriFast has a fundamentally different approach to the debugging process;
instead of reporting the results of symbolic execution step by step, the whole
verification is performed all at once, only showing details in the event of an
error (or a breakpoint being reached). There is no concept of exploring the
different execution paths of the program, severely limiting its ability to be
used as a tool for deepening one's understanding of separation logic. Multiple
branches of execution are not presented to the user, only showing the single
path taken to reach the error or breakpoint. Compare this rigid textual format
to the Gillian debugger's explorable execution map in
\autoref{fig:verifast-path-compare}; not only is the latter more feature rich,
it gives a full view of the program execution.

\begin{figure}
  \centering
  \begin{subfigure}[b]{0.4\textwidth}
    \center{}
    \includegraphics[width=0.75\textwidth]{img/verifast-path.png}
    \caption{The execution path information given by VeriFast}%
    \label{fig:verifast-path}
  \end{subfigure}
  \qquad
  \begin{subfigure}[b]{0.4\textwidth}
    \centering
    \includegraphics[width=0.9\textwidth]{img/execmap-final.png}
    \caption{The Gillian debugger's execution map}%
    \label{fig:execmap-final}
  \end{subfigure}
  \caption{Comparison of branch information given by VeriFast and the Gillian
  debugger respectively}%
  \label{fig:verifast-path-compare}
\end{figure}

VeriFast also gives no insight into the unification process; the only
information provided is an error message should unification fail. The Gillian
debugger gives more information to this end by showing all assertions from
a unification, up to and including the failing one.

\begin{figure}
  \centering
  \begin{subfigure}[b]{0.4\textwidth}
    \center{}
    \includegraphics[width=0.9\textwidth]{img/verifast-error.png}
    \caption{A unification error given by VeriFast}%
    \label{fig:verifast-error}
  \end{subfigure}
  \qquad
  \begin{subfigure}[b]{0.4\textwidth}
    \centering
    \includegraphics[width=0.3\textwidth]{img/unifymap-failure.png}
    \caption{A failing unification map given by the Gillian debugger}%
    \label{fig:unifymap-failure}
  \end{subfigure}
  \caption{Comparison of information for a failing unification, given by
  VeriFast and the Gillian debugger respectively}%
  \label{fig:verifast-unifyfail-compare}
\end{figure}

Another point of comparison is the accessibility of the different solutions.
VeriFast is a completely isolated tool, its graphical interface needing to be
run separately from any other software used for development. Now, armed with the
new debugging functionality, developers have a real possibility of using Gillian
as part of their development pipeline; the ability to debug Gillian verification
directly inside \sacha{use the name of VSCode here: "... inside VSCode - hiwch is by far the most popular editor in the world - is a ..." or something similar} what is, by far, the most popular editor in the world is a
previously unmatched level of accessibility for a tool of this purpose.

\sacha{You probably need concrete examples of debugging programs with bugs. And also, a concrete example of a BIG program (i.e. amazon-c string bug for example, non-lifted)}

\section{Limitations}%
\label{sec:eval:limitations}

There are some features that are desired of a Gillian debugger that are not yet
present, including:
\begin{itemize}
  \item Full support for target language lifting
  \item Decorating the source code during debugging
  \item Highlighting the relevant blocks of memory for the selected assertion
        when inspecting unification
  \item More efficient database logging
  \item A query language for the execution and unification trees
\end{itemize}

\sacha{If only these were the sole limitations. There's also the understanding of *why* an error is happening, for which there is no definitive answer, but the debugger could be improved with some heuristics. More immediately, there's also performance issues: logging is SLOW. That could be improved by targetting dynamic enabling of the logging or something, to only activate logging when required. }

However, all of these features are either relatively trivial to implement and
only missing due to time constraints, or more experimental features that require
substantial planning and are far outside the scope of this project.

Of course, none of that detracts from the fact that this project has elevated
Gillian from a prototype research tool to one that that proves useful in
pursuing new research in separation logic, and even more impressively, a tool
that can be used for educational purposes --- to help those having their first
experience of separation logic form a deeper understanding by automatically
applying its principles to real programs.

\polish{-- Section rewrite --}

Although this project has made immense progress towards making Gillian a more
user-friendly and mainstream tool, there are still limitations that need to be
overcome.

\paragraph{Incomplete target language lifting} As discussed \todo{discuss that
there} in \autoref{sec:debug-interface}, the mechanism to lift the debugging
process to the level of the target language is currently incomplete.
Thankfully, there are some very low hanging fruits, such as full support
for the lifting of \texttt{ExecMap}s. However, some challenges could constitute
entire Masters project on their own, such as the lifting of state and various
kind of errors to a point where no knowledge of GIL would be required to debug
the verification of a program written in, for example, JavaScript.

\paragraph{Lack of annotations on the GIL AST} As of now, it is possible, while
debugging, to highlight which part of the code is being symbolically executed.
However, there is no such similar mechanism that occurs during unification.
For example, the debugger is not highlighting what part of the state is being
affected by the consumption of an assertion.

\paragraph{Performances} Logging in Gillian is quite slow. In the past, the
creators of Gillian have put a lot of efforts into minimising the overhead of
the logging infrastructure when logging is disabled. Executing verification
and logging into a file (i.e. the old way) is about 5.75\footnotemark[1]{} times
slower than executing verification with logging disabled. In our new
infrastructure, executing verification and logging into the database is
2.32\footnotemark[1]{} times slower then when logging into a file, i.e.
13.35\footnotemark[1]{} times slower than when logging is disabled. For small
WISL programs, such as the ones studied in the Separation Logic course, it is
all a matter of fractions of seconds. However, the full verification of the
fragment of the \texttt{AWS Encryption SDK} takes about 6mn on a powerful
laptop, and the performance of the debugger would then become a deal-breaker.
\footnotetext[1]{Measures performed on the available benchmark for WISL
verification.} That being said, we are confident that these performances can be
massively improved through very low hanging fruits. The two most obvious are
\textbf{1)} making the database query asynchronous, and \textbf{2)} chosing a
more efficient serialised form than JSON. Interestingly, implementing \textbf{1)}
might end up making  logging into a database more efficient than logging
into a file, since logging into a file has to be done synchronously as to
preserve the order of the logs, while records can be written in any order in the
database and will still preserve the right structure.

\paragraph{Tool-developer experience} However powerful the logging infrastrcture
is, its API is far from perfect for the moment. Getting information that has
been loggeed from the database requires writing SQL queries by hand and calling
the OCaml-SQL driver. However, given the principled structure of the log trace,
we believe that this experience could be largely improved by designing a
domain-specific query language adapted to extracting any kind of information
from the traces. Note, however, that this limitation only affects the tool
developer, and does not affect the primary customer of this project, the tool
user.


Of course, none of that detracts from the fact that, from the point of view of
user interface, this project has elevated Gillian from a prototype research tool
to one that that proves useful in pursuing new research in separation logic,
and even more impressively, a tool that can be used for educational purposes ---
to help those having their first experience of separation logic form a deeper
understanding by automatically applying its principles to real programs.