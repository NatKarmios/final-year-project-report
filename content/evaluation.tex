%!TEX root = ../main.tex

\chapter{Evaluation}\label{sec:eval}

Due to the scarcity of similar tools, points of strong comparison for Gillian's
new debugger are few and far between. The best options to evaluate this project
against are the options available to Gillian users prior to this project (or
prior to any debugging work being done at all, as this project comes after
multiple years of work to this end), and to VeriFast, Gillian's closest
contemporary.

\section{Vs. Previous Gillian Debugging Methods}

Compared to the original debugging method --- manually reading the log file
resulting from verification --- the advantages of the visual debugger are
obvious. Not only does the file log require a deep understanding of Gillian's
internals, but it contains a vast amount of detail, often obfuscating the
information relevant to the encountered error. \sacha{It's a bit more than that. There's also the fact that reading text that describes a process is always less easy than reading a diagram that describes the same process. It's also, quite importantly, about how to navigate the log data.}
Even in the simple case of the recursive list length function, which was used as
a baseline throughout the project, a total of 9328 lines of logging output is
generated during verification. As a more precise comparison, about 1500 of those
lines concern unification of the postconditions, with a high degree of
redundancy and verbosity. This contrasts with what is essentially a few lines of
text in the debugger interface, with more detail available as and when the user
requires. Compared to the clear, clean, and concise interface of the new
solution, a far more ideal debugging process has been presented --- even those
with a deep understanding of Gillian, who are well acclimated to debugging via
the file log, intend to use this as their primary method of debugging moving
forwards.

The new debugger is also leaps and bounds ahead of the previous iteration;
aside from not having any unification information whatsoever, its use requires
a user to understand the quirks of the solution, such as branches being executed
one after the other with no means of discerning between then. The first debugger
was very much a case of attempting to move Gillian a step closer to debugging in
whatever manner was available, rather than setting out a clear vision of what
prospective users would desire from a program verification debugger, and working
to meet that goal.


\section{Vs. VeriFast}

VeriFast has a fundamentally different approach to the debugging process;
instead of reporting the results of symbolic execution step by step, the whole
verification is performed all at once, only showing details in the event of an
error (or a breakpoint being reached). There is no concept of exploring the
different execution paths of the program, severely limiting its ability to be
used as a tool for deepening one's understanding of separation logic. Multiple
branches of execution are not presented to the user, only showing the single
path taken to reach the error or breakpoint. Compare this rigid textual format
to the Gillian debugger's explorable execution map in
\autoref{fig:verifast-path-compare}; not only is the latter more feature rich,
it gives a full view of the program execution.

\begin{figure}
  \centering
  \begin{subfigure}[b]{0.4\textwidth}
    \center{}
    \includegraphics[width=0.75\textwidth]{img/verifast-path.png}
    \caption{The execution path information given by VeriFast}%
    \label{fig:verifast-path}
  \end{subfigure}
  \qquad
  \begin{subfigure}[b]{0.4\textwidth}
    \centering
    \includegraphics[width=0.9\textwidth]{img/execmap-final.png}
    \caption{The Gillian debugger's execution map}%
    \label{fig:execmap-final}
  \end{subfigure}
  \caption{Comparison of branch information given by VeriFast and the Gillian
  debugger respectively}%
  \label{fig:verifast-path-compare}
\end{figure}

VeriFast also gives no insight into the unification process; the only
information provided is an error message should unification fail. The Gillian
debugger gives more information to this end by showing all assertions from
a unification, up to and including the failing one.

\begin{figure}
  \centering
  \begin{subfigure}[b]{0.4\textwidth}
    \center{}
    \includegraphics[width=0.9\textwidth]{img/verifast-error.png}
    \caption{A unification error given by VeriFast}%
    \label{fig:verifast-error}
  \end{subfigure}
  \qquad
  \begin{subfigure}[b]{0.4\textwidth}
    \centering
    \includegraphics[width=0.3\textwidth]{img/unifymap-failure.png}
    \caption{A failing unification map given by the Gillian debugger}%
    \label{fig:unifymap-failure}
  \end{subfigure}
  \caption{Comparison of information for a failing unification, given by
  VeriFast and the Gillian debugger respectively}%
  \label{fig:verifast-unifyfail-compare}
\end{figure}

Another point of comparison is the accessibility of the different solutions.
VeriFast is a completely isolated tool, its graphical interface needing to be
run separately from any other software used for development. Now, armed with the
new debugging functionality, developers have a real possibility of using Gillian
as part of their development pipeline; the ability to debug Gillian verification
directly inside \sacha{use the name of VSCode here: "... inside VSCode - hiwch is by far the most popular editor in the world - is a ..." or something similar} what is, by far, the most popular editor in the world is a
previously unmatched level of accessibility for a tool of this purpose.

\sacha{You probably need concrete examples of debugging programs with bugs. And also, a concrete example of a BIG program (i.e. amazon-c string bug for example, non-lifted)}

\section{Limitations}%
\label{sec:eval:limitations}

There are some features that are desired of a Gillian debugger that are not yet
present, including:
\begin{itemize}
  \item Full support for target language lifting
  \item Decorating the source code during debugging
  \item Highlighting the relevant blocks of memory for the selected assertion
        when inspecting unification
  \item More efficient database logging
  \item A query language for the execution and unification trees
\end{itemize}

\sacha{If only these were the sole limitations. There's also the understanding of *why* an error is happening, for which there is no definitive answer, but the debugger could be improved with some heuristics. More immediately, there's also performance issues: logging is SLOW. That could be improved by targetting dynamic enabling of the logging or something, to only activate logging when required. }

However, all of these features are either relatively trivial to implement and
only missing due to time constraints, or more experimental features that require
substantial planning and are far outside the scope of this project.

Of course, none of that detracts from the fact that this project has elevated
Gillian from a prototype research tool to one that that proves useful in
pursuing new research in separation logic, and even more impressively, a tool
that can be used for educational purposes --- to help those having their first
experience of separation logic form a deeper understanding by automatically
applying its principles to real programs.
